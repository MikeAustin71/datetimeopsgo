package datetime

import (
	"fmt"
	"math/big"
	"sync"
	"time"
)

// LongTimeDuration - This type provides an alternative to time.Duration.
// time.Duration is limited in range to approximately 290-years. This type
// allows time duration computations which cover billions of years. This
// type is used exclusively in calculating time duration.
//
type LongTimeDuration struct {

	startDateTime    time.Time    // Starting Date Time

	endDateTime      time.Time    // Ending Date Time

	duration         *big.Int     // Time Duration expressed as a big.Int.
	                              // 'duration' is stored as a positive value

	sign             int          // Numerical sign of 'duration'. -1, 0, +1

	lock             *sync.Mutex  // Used for coordinating thread safe operations.
}

// New - Returns a new LongTimeDuration instance initialized to
// 'Zero' duration.
func (lngDur LongTimeDuration) New() LongTimeDuration {

	if lngDur.lock == nil {
		lngDur.lock = new(sync.Mutex)
	}

	lngDur.lock.Lock()

	defer lngDur.lock.Unlock()

	longDur := LongTimeDuration{}

	longDur.lock = new(sync.Mutex)

	longDur.duration = big.NewInt(0)

	longDur.sign = 0

	longDur.startDateTime = time.Time{}

	longDur.endDateTime = time.Time{}

	return longDur
}

// NewFromDuration - Initializes and returns a new instance of LongTimeDuration.
//
func (lngDur LongTimeDuration) NewFromDuration(
	startDateTime time.Time,
	duration time.Duration) (LongTimeDuration, error) {

	if lngDur.lock == nil {
		lngDur.lock = new(sync.Mutex)
	}

	lngDur.lock.Lock()

	ePrefix := "LongTimeDuration.NewFromDuration() "

	defer lngDur.lock.Unlock()

	longDur := LongTimeDuration{}

	longDur.lock = new(sync.Mutex)

	if duration < 0 {
		longDur.sign = -1
		duration = duration * -1
	} else if duration == 0 {
		longDur.sign = 0
	} else {
		longDur.sign = 1
	}

	longDur.duration = big.NewInt(0).SetInt64(int64(duration))

	lngDurUtil := longTimeDurationUtility{}
	var err error

	if longDur.sign == -1 {

		longDur.startDateTime,
		longDur.endDateTime,
		err = lngDurUtil.getStartDateMinusDuration(
			&longDur,
			startDateTime,
			ePrefix)

	} else {

		longDur.startDateTime,
		longDur.endDateTime,
		err = lngDurUtil.getStartDatePlusDuration(
			&longDur,
			startDateTime,
			ePrefix)

	}

	if err != nil {
		return LongTimeDuration{}, err
	}

	return longDur, nil
}

// AddDuration - Adds a time.Duration value to the total time duration
// maintained by the current instance of LongTimeDuration.
//
func (lngDur *LongTimeDuration) AddDuration(duration time.Duration) error {

	if lngDur.lock == nil {
		lngDur.lock = new(sync.Mutex)
	}

	lngDur.lock.Lock()

	defer lngDur.lock.Unlock()

	ePrefix := "LongTimeDuration.AddDuration() "

	lngDurUtil := longTimeDurationUtility{}

	return lngDurUtil.addDuration(
		lngDur,
		duration,
		ePrefix)
}

// IsValid - Analyzes the current instance of LongTimeDuration.
// If the time duration value is zero, the returned boolean value
// is set to true.
//
// If the current instance of LongTimeDuration is judged as 'invalid',
// an appropriate error message is returned.
//
func (lngDur *LongTimeDuration) IsValid() (isZero bool, err error) {

	if lngDur.lock == nil {
		lngDur.lock = new(sync.Mutex)
	}

	lngDur.lock.Lock()

	defer lngDur.lock.Unlock()

	ePrefix := "LongTimeDuration.IsValid() "

	lngDurUtil := longTimeDurationUtility{}

	isZero, err = lngDurUtil.isValid(
		lngDur,
		ePrefix)

	return isZero, err
}


// GenerateDatePlusDuration - Receives a starting date time and adds the
// duration value contained in the current LongTimeDuration instance.
// The date time generated by adding the current time duration value
// is returned as a type time.Time.
//
// This method will correctly process negative time duration values.
//
func (lngDur *LongTimeDuration) GenerateDatePlusDuration(
	baseDateTime time.Time) (finalStartDateTime, finalEndDateTime time.Time, err error) {

	if lngDur.lock == nil {
		lngDur.lock = new(sync.Mutex)
	}

	lngDur.lock.Lock()

	defer lngDur.lock.Unlock()

	ePrefix := "LongTimeDuration.GenerateDatePlusDuration() "

	if lngDur.duration == nil {
		return time.Time{},
		       time.Time{},
		       fmt.Errorf(ePrefix + "\n" +
			"Error: 'LongTimeDuration.duration' is nil and has NOT been initialized!\n")
	}

	lngDurUtil := longTimeDurationUtility{}

	if lngDur.sign == -1 {

		return lngDurUtil.getStartDateMinusDuration(
			lngDur,
			baseDateTime,
			ePrefix)
	}

	return lngDurUtil.getStartDatePlusDuration(
		lngDur,
		baseDateTime,
		ePrefix)
}


